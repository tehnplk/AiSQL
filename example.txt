import os
import sys
import tempfile
import webbrowser
from datetime import datetime
import re
# Standard library imports

# Third-party imports
import pandas as pd
import openpyxl
import json

# PyQt6 imports
from PyQt6.QtCore import (
    Qt,
    pyqtSignal,
    QThread,
    QObject,
    QAbstractTableModel,
    QModelIndex,
    QSortFilterProxyModel,
)
from PyQt6.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QDialog,
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QMessageBox,
    QPushButton,
    QTableView,
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QComboBox,
    QLineEdit,
    QSplitter,
    QFrame,
    QSizePolicy,
    QScrollArea,
    QSpacerItem,
    QProgressBar,
    QMenu,
    QFormLayout,
    QCheckBox,
    QDialogButtonBox,
)
from PyQt6.QtGui import (
    QFont,
    QIcon,
    QKeySequence,
    QShortcut,
    QStandardItemModel,
    QPainter,
    QPixmap,
    QAction,
    QColor,
)

# Handle imports with robust fallback
try:
    # First try relative imports (works when part of package)
    from .ColumnFilterDialog import ColumnFilterDialog
    from .Db import Db
    from .PandasModel import PandasModel as PandasTableModel
    from .ReportResult_ui import ReportResult_ui
    from .Utils import check_cid_his_doctor
except ImportError:
    # Fallback to direct import if relative import fails
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
    from ColumnFilterDialog import ColumnFilterDialog
    from Db import Db
    from PandasModel import PandasModel as PandasTableModel
    from ReportResult_ui import ReportResult_ui
    from Utils import check_cid_his_doctor

try:
    # Imports from project root with fallback
    from AppSetting import settings
except ImportError:
    # Fallback to direct import if relative import fails
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
    from AppSetting import settings

# Import modules using direct imports


class FilterDialog(QDialog):
    def __init__(self, column_name, parent=None):
        super().__init__(parent)
        self.column_name = column_name
        self.filter_text = ""
        self.setup_ui()

    def setup_ui(self):
        self.setWindowTitle("กรองข้อมูล")
        self.setFixedSize(400, 200)

        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        # Filter label
        filter_label = QLabel(f"กรอง ({self.column_name})")
        filter_label.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        layout.addWidget(filter_label)

        # Big text input
        self.filter_input = QLineEdit()
        self.filter_input.setFont(QFont("Arial", 11))
        self.filter_input.setPlaceholderText("ป้อนข้อความที่ต้องการค้นหา...")
        self.filter_input.setMinimumHeight(40)
        layout.addWidget(self.filter_input)

        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        self.ok_button = QPushButton("ตกลง")
        self.ok_button.setMinimumSize(80, 35)
        self.ok_button.clicked.connect(self.accept)

        self.cancel_button = QPushButton("ยกเลิก")
        self.cancel_button.setMinimumSize(80, 35)
        self.cancel_button.clicked.connect(self.reject)

        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)

        layout.addLayout(button_layout)

        # Focus on input
        self.filter_input.setFocus()

        # Enter key to accept
        self.filter_input.returnPressed.connect(self.accept)

    def get_filter_text(self):
        return self.filter_input.text().strip()

    def set_filter_text(self, text):
        self.filter_input.setText(text)


class PandasTableModel(QAbstractTableModel):
    """Table model for pandas DataFrame with filtering and sorting support."""

    def __init__(self, dataframe=None):
        super().__init__()
        self._dataframe = dataframe if dataframe is not None else pd.DataFrame()
        self._original_dataframe = self._dataframe.copy()
        self.column_filters = {}  # Store filters for each column
        self._sort_column = None
        self._sort_order = Qt.SortOrder.AscendingOrder

    def rowCount(self, parent=None):
        return len(self._dataframe)

    def columnCount(self, parent=None):
        return len(self._dataframe.columns)

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        if role == Qt.ItemDataRole.DisplayRole:
            value = self._dataframe.iloc[index.row(), index.column()]
            return str(value) if pd.notna(value) else ""

        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                # Add sort indicator to column header
                header = str(self._dataframe.columns[section])
                if section == self._sort_column:
                    sort_indicator = (
                        " ↑"
                        if self._sort_order == Qt.SortOrder.AscendingOrder
                        else " ↓"
                    )
                    header += sort_indicator
                return header
            else:
                return str(section + 1)
        return None

    def sort(self, column, order):
        """Sort table by given column number."""
        self.layoutAboutToBeChanged.emit()

        column_name = self._dataframe.columns[column]
        ascending = order == Qt.SortOrder.AscendingOrder

        # Sort the dataframe
        self._dataframe = self._dataframe.sort_values(
            by=column_name,
            ascending=ascending,
            na_position="last",
            key=lambda col: col.astype(str).str.lower(),
        )

        # Store sort state
        self._sort_column = column
        self._sort_order = order

        self.layoutChanged.emit()
        self.headerDataChanged.emit(
            Qt.Orientation.Horizontal, 0, self.columnCount() - 1
        )

    def set_dataframe(self, dataframe):
        """Set new dataframe data."""
        self.beginResetModel()
        self._dataframe = dataframe.copy()
        self._original_dataframe = dataframe.copy()
        self.column_filters = {}
        self.endResetModel()

    def apply_filters(self):
        """Apply all column filters to the dataframe using 'contains' method."""
        self.beginResetModel()

        filtered_df = self._original_dataframe.copy()

        for column, filter_text in self.column_filters.items():
            if column in filtered_df.columns and filter_text:
                # Convert column to string and apply contains filter (case-insensitive)
                filtered_df = filtered_df[
                    filtered_df[column]
                    .astype(str)
                    .str.contains(filter_text, case=False, na=False, regex=False)
                ]

        self._dataframe = filtered_df
        self.endResetModel()

    def set_column_filter(self, column, filter_text):
        """Set filter for a specific column using 'contains' method.

        Args:
            column: Column name to filter on
            filter_text: Text to search for within the column
        """
        if filter_text:
            self.column_filters[column] = filter_text
        else:
            self.column_filters.pop(column, None)
        self.apply_filters()

    def get_unique_values(self, column):
        """Get unique values for a column."""
        if column in self._original_dataframe.columns:
            return self._original_dataframe[column].dropna().unique().tolist()
        return []


class QueryExecutor(QThread):
    """Background thread for executing SQL queries."""

    finished = pyqtSignal(list, list)  # results, columns
    error = pyqtSignal(str)
    progress = pyqtSignal(str)

    def __init__(self, sql_command):
        super().__init__()
        self.sql_command = sql_command

    def run(self):
        """Execute the SQL query in background."""
        try:
            self.progress.emit("กำลังเชื่อมต่อฐานข้อมูล...")
            db = Db()

            self.progress.emit("กำลังดำเนินการคิวรี...")
            results, columns = db.execute_query_with_columns(self.sql_command)

            if results:
                # Results are already in dictionary format from Db class
                self.progress.emit("สำเร็จ")
                self.finished.emit(results, columns)
            else:
                self.finished.emit([], [])

        except Exception as e:
            self.error.emit(f"เกิดข้อผิดพลาด: {str(e)}")


class ReportResultDialog(ReportResult_ui):
    """Dialog to display SQL query results."""

    def __init__(
        self,
        hash_cid=None,
        report_id=None,
        report_name=None,
        sql_individual=None,
        sql_summary=None,
        send_ssj=False,
        report_update=None,
        parent=None,
    ):
        """Initialize the dialog with report data.

        Args:
            hash_cid (str, optional): User's hash ID for authentication
            report_id (str, optional): Unique identifier for the report
            report_name (str): Name of the report to display
            sql_individual (str): SQL query for individual records
            sql_summary (str, optional): SQL query for summary data
            send_ssj (bool, optional): Whether to enable SSJ sending
            report_update (str, optional): Last update timestamp
            parent: Parent widget
        """
        super().__init__(parent)

        # Store original values for cancel operations
        self.original_report_name = report_name or ""
        self.original_sql_individual = sql_individual or ""
        self.original_sql_summary = sql_summary or ""
        self.original_send_ssj = send_ssj or False
        self.original_report_update = report_update or ""

        # Current values
        self.hash_cid = hash_cid
        self.report_id = report_id
        self.report_name = report_name or ""
        self.sql_individual = sql_individual or ""
        self.sql_summary = sql_summary or ""
        self.send_ssj = send_ssj or False
        self.report_update = report_update or ""

        # Initialize other instance variables
        self.query_executor = None
        self.results_data = []
        self.columns_data = []
        self.pandas_model = None
        self.parent_widget = parent
        self.is_cancelling = False

        # If we have a report ID, try to load any missing data
        if self.report_id and not all([self.report_name, self.sql_individual]):
            self._load_report_data()

        # Ensure we have empty strings instead of None
        self.report_name = self.report_name or ""
        self.sql_individual = self.sql_individual or ""
        self.sql_summary = self.sql_summary or ""

        # Set up the UI
        self.setupUi()
        self.setup_table_context_menu()

        # Update the window title with report info
        self.update_window_title()

        # Set the SQL text after UI is set up
        if hasattr(self, "sql_individual_widget"):
            self.sql_individual_widget.setPlainText(self.sql_individual)

        # Set focus to the process button
        if hasattr(self, "process_button"):
            self.process_button.setFocus()

    def closeEvent(self, event):
        """Handle window close event."""
        # If we're in the middle of cancelling, just close
        if hasattr(self, "is_cancelling") and self.is_cancelling:
            event.accept()
            return

        # If in edit mode, ask if user wants to save changes
        if hasattr(self, "edit_save_button") and self.edit_save_button.isChecked():
            reply = QMessageBox.question(
                self,
                "ยืนยันการปิด",
                "คุณต้องการบันทึกการเปลี่ยนแปลงหรือไม่?",
                QMessageBox.StandardButton.Yes
                | QMessageBox.StandardButton.No
                | QMessageBox.StandardButton.Cancel,
                QMessageBox.StandardButton.Cancel,
            )

            if reply == QMessageBox.StandardButton.Yes:
                new_name = self.title_edit.text().strip()
                # Handle sql_individual as string or QTextEdit object
                if hasattr(self.sql_individual, "toPlainText"):
                    new_sql = self.sql_individual.toPlainText().strip()
                else:
                    new_sql = self.sql_individual.strip()
                if not self.save_report_changes(new_name, new_sql):
                    event.ignore()
                    return
            elif reply == QMessageBox.StandardButton.Cancel:
                event.ignore()
                return

        # Close the database connection if it exists
        if hasattr(self, "db") and self.db:
            self.db.close()

        # Call parent closeEvent
        super().closeEvent(event)

    def setup_table_context_menu(self):
        """Setup context menu for table headers."""
        header = self.results_table.horizontalHeader()
        header.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        header.customContextMenuRequested.connect(self.show_header_context_menu)

    def show_header_context_menu(self, position):
        """Show context menu on header right-click."""
        if self.pandas_model is None:
            return

        header = self.results_table.horizontalHeader()
        logical_index = header.logicalIndexAt(position)

        if logical_index < 0:
            return

        column_name = self.pandas_model.headerData(
            logical_index, Qt.Orientation.Horizontal, Qt.ItemDataRole.DisplayRole
        )

        menu = QMenu(self)

        # Filter action
        filter_action = menu.addAction(f"กรองคอลัมน์ '{column_name}'")
        filter_action.triggered.connect(lambda: self.show_filter_dialog(column_name))

        # Clear filter action (only if filter exists)
        if column_name in self.pandas_model.column_filters:
            clear_action = menu.addAction(f"ยกเลิกการกรองคอลัมน์ '{column_name}'")
            clear_action.triggered.connect(
                lambda: self.clear_column_filter(column_name)
            )

        # Clear all filters action (only if any filters exist)
        if self.pandas_model.column_filters:
            menu.addSeparator()
            clear_all_action = menu.addAction("ยกเลิกการกรองทั้งหมด")
            clear_all_action.triggered.connect(self.clear_all_filters)

        menu.exec(header.mapToGlobal(position))

    def show_filter_dialog(self, column_name):
        """Show filter dialog for a column with 'contains' filtering."""
        if not hasattr(self, "pandas_model") or not self.pandas_model:
            return

        # Get current filter text if exists
        current_filter = self.pandas_model.column_filters.get(column_name, "")

        # Create and configure the filter dialog
        dialog = FilterDialog(column_name, self)

        # Set current filter text if exists
        if current_filter:
            dialog.set_filter_text(current_filter)

        if dialog.exec():
            filter_text = dialog.get_filter_text()
            self.pandas_model.set_column_filter(column_name, filter_text)
            self.update_status_after_filter()

    def clear_column_filter(self, column_name):
        """Clear filter for a specific column."""
        if self.pandas_model and column_name in self.pandas_model.column_filters:
            del self.pandas_model.column_filters[column_name]
            self.pandas_model.apply_filters()
            self.update_status_after_filter()

    def clear_all_filters(self):
        """Clear all column filters."""
        if self.pandas_model:
            self.pandas_model.column_filters.clear()
            self.pandas_model.apply_filters()
            self.update_status_after_filter()

    def update_status_after_filter(self):
        """Update status label after filtering."""
        if self.pandas_model:
            filtered_count = self.pandas_model.rowCount()
            total_count = len(self.pandas_model._original_dataframe)

            if filtered_count == total_count:
                self.status_label.setText(f"พบข้อมูล {total_count} รายการ")
            else:
                self.status_label.setText(
                    f"แสดงข้อมูล {filtered_count} จาก {total_count} รายการ (กรองแล้ว)"
                )

    def update_window_title(self):
        """Update the window title with report ID and name."""
        if self.report_id:
            self.setWindowTitle(f"({self.report_id})-{self.report_name}")
        else:
            self.setWindowTitle(f"{self.report_name}")

    def _get_reports_path(self):
        """Get the path to reports.json in the data directory.

        Returns:
            str: Full absolute path to reports.json
        """
        # Get the project root directory
        if getattr(sys, "frozen", False):
            # For frozen app (pyinstaller)
            project_root = os.path.dirname(sys.executable)
        else:
            # For development - go up one level from EMR directory to project root
            project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

        # Return the path to ./data/reports.json relative to project root
        return os.path.join(project_root, "data", "reports.json")

    def _load_report_data(self):
        """Load report data from reports.json based on report ID."""
        if not self.report_id:
            return

        try:
            import os
            import json
            from datetime import datetime

            reports_file = self._get_reports_path()
            if not os.path.exists(reports_file):
                print(f"Reports file not found at: {reports_file}")
                return

            with open(reports_file, "r", encoding="utf-8") as f:
                reports = json.load(f)

            # Find the report with matching ID
            for report in reports:
                if str(report.get("id")) == str(self.report_id):
                    # Update fields if they're not already set
                    if not self.report_name and "name" in report:
                        self.report_name = report["name"]
                        self.original_report_name = report["name"]

                    if not self.sql_individual and "sql_individual" in report:
                        self.sql_individual = report["sql_individual"]
                        self.original_sql_individual = report["sql_individual"]

                    if not self.sql_summary and "sql_summary" in report:
                        self.sql_summary = report["sql_summary"]
                        self.original_sql_summary = report["sql_summary"]

                    if "send_ssj" in report:
                        self.send_ssj = report["send_ssj"]
                        self.original_send_ssj = report["send_ssj"]

                    if "report_update" in report:
                        self.report_update = report["report_update"]
                        self.original_report_update = report["report_update"]

                    # Update the window title if we have new data
                    self.update_window_title()
                    break

        except Exception as e:
            print(f"Error loading report data: {e}")

    def _load_report_id(self):
        """Legacy method to load report ID from reports.json based on report name and SQL command.
        Kept for backward compatibility but should be deprecated in favor of _load_report_data.
        """
        if not self.report_name or not self.sql_individual:
            return

        try:
            reports_file = self._get_reports_path()
            if not os.path.exists(reports_file):
                return

            with open(reports_file, "r", encoding="utf-8") as f:
                reports = json.load(f)

            for report in reports:
                if (
                    report.get("name") == self.report_name
                    and report.get("sql_individual") == self.sql_individual
                ):
                    self.report_id = report.get("id")
                    break

        except Exception as e:
            print(f"Error loading report ID: {e}")

    def toggle_edit_mode(self, checked, from_cancel=False):
        """Toggle edit mode for report name and SQL command.

        Args:
            checked: Whether edit mode should be enabled
            from_cancel: If True, this was triggered by the cancel button
        """
        if checked:
            # Store original values in case of cancel
            self.original_name = self.title_edit.text()
            self.original_sql = self.sql_individual_widget.toPlainText()

            # Enter edit mode - enable editing for both title and SQL
            self.edit_save_button.setText("บันทึก")
            self.title_edit.setReadOnly(False)  # Make title editable

            # Make sql_individual editable
            self.sql_individual_widget.setReadOnly(False)
            self.sql_individual_widget.setStyleSheet(
                """
                QTextEdit {
                    background-color: white;
                    border: 1px solid #2196F3;
                    border-radius: 4px;
                    font-family: 'Courier New', monospace;
                    font-size: 9pt;
                    padding: 5px;
                }
                """
            )
            # Show SQL display and ensure toggle button state is correct
            self.sql_individual_widget.setVisible(True)
            self.sql_toggle_button.setChecked(True)
            self.sql_individual_widget.setFocus()

            # Show cancel button
            self.cancel_button.setVisible(True)
        else:
            # Validate input
            new_name = self.title_edit.text().strip()
            new_sql = self.sql_individual_widget.toPlainText().strip()

            if not new_name:
                QMessageBox.warning(self, "คำเตือน", "กรุณาระบุชื่อรายงาน")
                return

            if not new_sql:
                QMessageBox.warning(self, "คำเตือน", "กรุณาระบุคำสั่ง SQL")
                return

            # Save changes
            self.report_name = new_name
            self.sql_individual = new_sql
            self.setWindowTitle(f"{self.report_name}")

            # Exit edit mode
            self.exit_edit_mode()

            # Save to file
            self.save_report_changes(new_name, new_sql)

    def cancel_edit(self):
        """Cancel edit mode and revert changes."""
        try:
            # Restore original values
            self.title_edit.setText(self.original_name)
            self.sql_individual_widget.setPlainText(self.original_sql)

            # Exit edit mode
            self.exit_edit_mode()

            # Reset the edit button state
            self.edit_save_button.setChecked(False)

        except Exception as e:
            print(f"Error canceling edit: {e}")
            QMessageBox.critical(
                self, "ข้อผิดพลาด", f"เกิดข้อผิดพลาดในการยกเลิกการแก้ไข: {str(e)}"
            )

    def exit_edit_mode(self):
        """Exit edit mode and update UI."""
        try:
            # Set widgets to read-only
            self.title_edit.setReadOnly(True)
            self.sql_individual_widget.setReadOnly(True)
            self.sql_individual_widget.setVisible(False)

            # Reset button text and state
            self.edit_save_button.setText("แก้ไข")
            self.edit_save_button.setChecked(False)

            # Hide cancel button
            self.cancel_button.setVisible(False)

            # Reset style
            self.sql_individual_widget.setStyleSheet(
                """
                QTextEdit {
                    background-color: #F5F5F5;
                    border: 1px solid #E0E0E0;
                    border-radius: 4px;
                    font-family: 'Courier New', monospace;
                    font-size: 9pt;
                    padding: 5px;
                }
                QTextEdit:read-only {
                    background-color: #F5F5F5;
                }
                QTextEdit:focus {
                    background-color: white;
                    border: 1px solid #2196F3;
                }
                """
            )

            # Update the parent widget's reports list if available
            if hasattr(self.parent_widget, "load_reports"):
                self.parent_widget.load_reports()

        except Exception as e:
            print(f"Error in exit_edit_mode: {e}")
            QMessageBox.critical(
                self, "ข้อผิดพลาด", f"เกิดข้อผิดพลาดในการออกจากการแก้ไข: {str(e)}"
            )

    def save_report_changes(self, new_name, new_sql):
        """Save changes to reports.json.

        Args:
            new_name (str): New report name
            new_sql (str): New SQL command

        Returns:
            bool: True if save was successful, False otherwise
        """
        if not self.report_id:
            return False

        try:
            import os
            import json
            from datetime import datetime

            reports_file = self._get_reports_path()

            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(reports_file), exist_ok=True)

            # If file doesn't exist, create an empty list
            if not os.path.exists(reports_file):
                reports = []
                print(f"Created new reports file at: {reports_file}")
            else:
                # Read existing reports
                with open(reports_file, "r", encoding="utf-8") as f:
                    reports = json.load(f)

            # Find and update the report
            updated = False
            for report in reports:
                if str(report.get("id")) == str(self.report_id):
                    report["name"] = new_name
                    report["sql_individual"] = new_sql
                    report["report_update"] = datetime.now().strftime("%Y-%m-%d")
                    updated = True
                    break

            if not updated:
                QMessageBox.warning(self, "ข้อผิดพลาด", "ไม่พบรายงานที่จะอัปเดต")
                return False

            # Save back to file
            with open(reports_file, "w", encoding="utf-8") as f:
                json.dump(reports, f, ensure_ascii=False, indent=2, default=str)

            # Update internal state
            self.report_name = new_name
            self.sql_individual = new_sql
            self.report_update = datetime.now().strftime("%Y-%m-%d")

            # Update window title with new name
            self.update_window_title()

            # Update parent's report list if available
            if self.parent_widget and hasattr(self.parent_widget, "load_reports"):
                self.parent_widget.load_reports()

            return True

        except Exception as e:
            QMessageBox.critical(self, "ข้อผิดพลาด", f"เกิดข้อผิดพลาดในการบันทึก: {str(e)}")
            return False

    def toggle_sql_display(self):
        """Toggle SQL command display visibility."""
        if hasattr(self, "sql_individual_widget"):
            self.sql_individual_widget.setVisible(self.sql_toggle_button.isChecked())

    def delete_report(self):
        """Delete the current report after confirmation."""
        if not self.report_id:
            QMessageBox.warning(self, "Delete Error", "No report selected for deletion")
            return
            
        # Ask for confirmation
        reply = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete report '{self.report_name}'?\nThis action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            try:
                # Get the path to reports.json
                reports_path = self._get_reports_path()
                
                # Load the current reports
                with open(reports_path, 'r', encoding='utf-8') as f:
                    reports = json.load(f)
                
                # Find and remove the current report
                updated_reports = [r for r in reports if str(r.get('id')) != str(self.report_id)]
                
                # Save the updated reports
                with open(reports_path, 'w', encoding='utf-8') as f:
                    json.dump(updated_reports, f, ensure_ascii=False, indent=2)
                
                # Close this dialog
                self.accept()
                
                # Notify parent to refresh the report list if possible
                if self.parent_widget and hasattr(self.parent_widget, 'load_reports'):
                    self.parent_widget.load_reports()
                
                QMessageBox.information(
                    self,
                    "Report Deleted",
                    f"Report '{self.report_name}' has been deleted successfully."
                )
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Deletion Error",
                    f"Failed to delete report: {str(e)}"
                )
                import traceback
                print(traceback.format_exc())

    def export_sql(self):
        """Export the current report's JSON data to a .json file."""
        if not self.report_id:
            QMessageBox.warning(self, "Export Error", "No report ID available for export")
            return
            
        try:
            # Get the path to reports.json
            reports_path = self._get_reports_path()
            
            # Load the reports data
            with open(reports_path, 'r', encoding='utf-8') as f:
                reports = json.load(f)
            
            # Find the current report by ID
            current_report = None
            for report in reports:
                if str(report.get('id')) == str(self.report_id):
                    current_report = report
                    break
            
            if not current_report:
                QMessageBox.warning(self, "Export Error", "Current report not found in reports.json")
                return
            
            # Create a safe filename from the report name
            safe_name = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in self.report_name)
            safe_name = safe_name.strip()
            
            # Get the default save directory (user's Documents folder)
            docs_path = os.path.expanduser('~/Documents')
            if not os.path.exists(docs_path):
                docs_path = os.path.expanduser('~')  # Fallback to home directory
            
            # Suggest a filename
            default_filename = f"{safe_name}.json"
            default_path = os.path.join(docs_path, default_filename)
            
            # Ask user for save location
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save Report JSON",
                default_path,
                "JSON Files (*.json);;All Files (*)"
            )
            
            if not file_path:
                return  # User cancelled
                
            # Ensure .json extension
            if not file_path.lower().endswith('.json'):
                file_path += '.json'
            
            # Save the report data as a JSON array with one element
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump([current_report], f, ensure_ascii=False, indent=2)
            
            # Show success message
            QMessageBox.information(
                self,
                "Export Successful",
                f"Report exported successfully to:\n{file_path}"
            )
            
        except Exception as e:
            QMessageBox.critical(
                self,
                "Export Error",
                f"Failed to export report: {str(e)}"
            )
            import traceback
            print(traceback.format_exc())


    def execute_query(self):
        """Execute the SQL query and display results."""
        # Check if the user has permission to access patient records
        if not check_cid_his_doctor(self.hash_cid):
            QMessageBox.information(
                self,
                "Permission Denied",
                "ท่านไม่มีสิทธิ์เข้าถึงข้อมูลเวชระเบียนผู้ป่วยใน HIS นี้",
            )
            return

        # Check HIS profile first
        try:
            db = Db()
            if db.his_profile != "HOSXP":
                QMessageBox.warning(self, "ข้อผิดพลาด", "ยังไม่รองรับ HIS อื่น")
                return
        except Exception as e:
            QMessageBox.critical(self, "ข้อผิดพลาด", f"ไม่สามารถตรวจสอบ HIS Profile: {e}")
            return

        # Hide SQL text box and uncheck toggle button
        if hasattr(self, "sql_individual_widget"):
            self.sql_individual_widget.setVisible(False)
        self.sql_toggle_button.setChecked(False)

        # Disable process button and show progress
        self.process_button.setEnabled(False)
        self.process_button.setText("กำลังประมวลผล...")
        self.progress_bar.show()
        self.progress_label.setText("กำลังเตรียมข้อมูล...")

        # Clear previous results (handled by setting model to None or clearing model later)

        # Use the text from the editable SQL display
        sql_to_execute = self.sql_individual_widget.toPlainText().strip()

        # Prevent execution of modifying queries
        forbidden_keywords = [
            "INSERT",
            "UPDATE",
            "DELETE",
            "ALTER",
            "CREATE",
            "DROP",
            "TRUNCATE",
        ]
        if any(keyword in sql_to_execute.upper() for keyword in forbidden_keywords):
            error_message = "ไม่อนุญาตให้ดำเนินการคำสั่ง SQL ที่แก้ไขข้อมูลหรือโครงสร้างฐานข้อมูล"
            self.on_query_error(error_message)  # Use the existing error handling method
            return

        try:
            sql_command = sql_to_execute.encode("utf-8").decode("utf-8")
            # Replace any problematic Unicode characters
            sql_command = re.sub(r"[\u0000-\u001F\u007F-\u009F]", " ", sql_command)
        except UnicodeError:
            sql_command = sql_to_execute.encode("utf-8", errors="replace").decode("utf-8")
        self.query_executor = QueryExecutor(sql_command)
        self.query_executor.finished.connect(self.on_query_finished)
        self.query_executor.error.connect(self.on_query_error)
        self.query_executor.progress.connect(self.on_progress_update)
        self.query_executor.start()

    def on_progress_update(self, message):
        """Update progress display."""
        self.progress_label.setText(message)

    def on_query_finished(self, results, columns):
        """Handle successful query completion."""
        # Restore button state
        self.process_button.setEnabled(True)
        self.process_button.setText("ประมวลผล")
        self.progress_bar.hide()
        self.progress_label.setText("พร้อมดำเนินการ")

        if not results:
            self.status_label.setText("ไม่พบข้อมูล")
            # Show no data message
            model = QStandardItemModel(1, 1)
            model.setHorizontalHeaderLabels(["ผลลัพธ์"])
            item = QStandardItem("ไม่พบข้อมูลที่ตรงกับเงื่อนไข")
            item.setEditable(False)
            model.setItem(0, 0, item)
            self.results_table.setModel(model)
            self.pandas_model = None
            return

        # Convert results to pandas DataFrame
        # Convert dictionary results to list format to preserve column order
        if results and isinstance(results[0], dict):
            # Convert dict results to list format preserving column order
            list_results = []
            for row_dict in results:
                row_list = [row_dict.get(col, None) for col in columns]
                list_results.append(row_list)
            df = pd.DataFrame(list_results, columns=columns)
        else:
            df = pd.DataFrame(
                results, columns=columns
            )  # Specify column order from SQL query

        # Create pandas model
        self.pandas_model = PandasTableModel(df)

        # Set model to table and enable sorting
        self.results_table.setModel(self.pandas_model)
        self.results_table.setSortingEnabled(True)
        self.results_table.sortByColumn(
            0, Qt.SortOrder.AscendingOrder
        )  # Sort by first column by default
        self.results_table.resizeColumnsToContents()

        # Update status
        self.status_label.setText(f"พบข้อมูล {len(results)} รายการ")
        self.export_button.setEnabled(True)
        self.results_data = results
        self.columns_data = columns

    def on_query_error(self, error_message):
        """Handle query error."""
        # Restore button state
        self.process_button.setEnabled(True)
        self.process_button.setText("ประมวลผล")
        self.progress_bar.hide()
        self.progress_label.setText("เกิดข้อผิดพลาด")

        self.status_label.setText("เกิดข้อผิดพลาดในการประมวลผล")

        # Show error in a message box instead of the table
        QMessageBox.critical(self, "ข้อผิดพลาด", error_message)
        self.results_table.setModel(None)  # Clear the view

    def export_to_excel(self):
        """Export results to Excel file."""
        try:
            from PyQt6.QtWidgets import QFileDialog
            from datetime import datetime

            # Get save location
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_filename = f"report_{timestamp}.xlsx"

            filename, _ = QFileDialog.getSaveFileName(
                self, "บันทึกไฟล์", default_filename, "Excel Files (*.xlsx);;All Files (*)"
            )

            if filename:
                # Export filtered data if available, otherwise export original data
                if self.pandas_model and hasattr(self.pandas_model, "_dataframe"):
                    df = self.pandas_model._dataframe
                else:
                    df = pd.DataFrame(self.results_data)

                # Save to Excel
                df.to_excel(filename, index=False, engine="openpyxl")

                QMessageBox.information(
                    self,
                    "สำเร็จ",
                    f"ส่งออกข้อมูลเรียบร้อยแล้ว\n{filename}\nจำนวนแถว: {len(df)}",
                )

        except Exception as e:
            QMessageBox.critical(self, "ข้อผิดพลาด", f"ไม่สามารถส่งออกข้อมูลได้: {str(e)}")


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # Test dialog
    dialog = ReportResultDialog("Test Report", "SELECT 1 as test_column", None)
    dialog.show()

    sys.exit(app.exec())